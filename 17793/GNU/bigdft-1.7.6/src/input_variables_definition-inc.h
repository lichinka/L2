"# Definitions of the input variables\n"
"##inputvar: #name of the variable as declared in the code\n"
"## DESCRIPTION: Extended description of the variable to be used for documentation\n"
"## COMMENT: This is the description of the variable as will appear in the logfile\n"
"## RANGE: [from,to] #always put two numbers (also .inf can be put)\n"
"## EXCLUSIVE: #here follows a list of allowed values (either RANGE or EXCLUSIVE)\n"
"##  - Value1:  comments of value1\n"
"##  - Value2:  comment of value2\n"
"## CONDITION: #here the conditions for which the variable makes sense are written\n"
"##   MASTER_KEY: foo #this means that inputvar makes sense only if foo is specified\n"
"##   WHEN: #provide a list of allowed values of foo for which inputvars is meaningful\n"
"##     - fooval1\n"
"##     - fooval2   \n"
"## PROFILE_FROM: foo #inputvar inherit the profile from the one specified by foo variable\n"
"###then the profiles follows, which gives to the variables the allowed name\n"
"## default: value of the default, written as a string \n"
"## profile1: value1 # if the user specifies inputvar: profile1 then inputvars will be value1\n"
"## profile2: value2\n"
"##\n"
"## DO NOT USE the character ':' and "" in the COMMENT of DESCRIPTION\n"
"############################################\n"
"# Density Functional Theory parameters\n"
" dft:\n"
"   DESCRIPTION: Density Functional Theory parameters\n"
"   hgrids:\n"
"     COMMENT: Grid spacing in the three directions (bohr)\n"
"     DESCRIPTION: |\n"
"      Grid spacing in three directions (Bohr units) of the coarse mesh as [0.5, 0.45, 0.4].\n"
"      A scalar can also be given as 0.45.\n"
"     RANGE: [0., 2.]\n"
"     default: [0.45, 0.45, 0.45]\n"
"     fast: [0.55, 0.55, 0.55]\n"
"     accurate: [0.30, 0.30, 0.30]\n"
"   rmult:\n"
"     COMMENT: c(f)rmult*radii_cf(:,1(2))=coarse(fine) atom-based radius\n"
"     DESCRIPTION: Coarse and fine multiplier as [4.0, 8.0].\n"
"                 These numbers determine the extension of the coarse and fine region respectively.\n"
"     RANGE: [0., 100.]\n"
"     default: [5., 8.]\n"
"   ixc:\n"
"     COMMENT: Exchange-correlation parameter (LDA=1,PBE=11)\n"
"     DESCRIPTION: Determine the exchange-correlation functional.\n"
"     default: 1\n"
"     #Here follow a number of possibilities for the different XC functionals\n"
"     LDA (ABINIT): 1\n"
"     PBE (ABINIT): 11\n"
"     LDA: -20\n"
"     PBE: -101130\n"
"     PBE0: -406\n"
"     B97-D: -170 #to be verified\n"
"     B3LYP: -402\n"
"     HF: 100 #Hartree-Fock\n"
"   ncharge:\n"
"     COMMENT: Charge of the system\n"
"     DESCRIPTION: Total charge of the system. A negative value means that extra electrons are added.\n"
"     RANGE: [-500., 500.]\n"
"     default: 0\n"
"   elecfield:\n"
"     COMMENT: Electric field (Ex,Ey,Ez)\n"
"     default: [0., 0., 0.]\n"
"   nspin:\n"
"     COMMENT: Spin polarization treatment\n"
"     DESCRIPTION: |\n"
"            Spin polarization treatment;\n"
"            1 no spin (as LDA),\n"
"            2 spin-polarisation (LSD or collinear) and\n"
"            4 non-collinear i.e. two components per electron.\n"
"     EXCLUSIVE:\n"
"       1: No spin\n"
"       2: Collinear\n"
"       4: Non-collinear\n"
"     default: 1\n"
"   mpol:\n"
"     COMMENT: Total magnetic moment\n"
"     DESCRIPTION: Total magnetic moment which has to be the same parity \n"
"                  as the total number of electrons (nelec_up-nelec_down=mpol).\n"
"                  You should also define the keyword 'IGSpin' or add a spin per atom to specify the polarisation for the input guess.\n"
"     default: 0\n"
"   gnrm_cv:\n"
"     COMMENT: convergence criterion gradient\n"
"     DESCRIPTION: Maximal value of the norm 2 of the electronic orbitals used as convergence criterion\n"
"     RANGE: [0., 1.]\n"
"     default: 1.e-4\n"
"     fast: 1.e-3\n"
"     accurate: 1.e-5\n"
"   itermax:\n"
"     COMMENT: Max. iterations of wfn. opt. steps\n"
"     RANGE: [0, 10000]\n"
"     default: 50\n"
"   itermin:\n"
"     COMMENT: Min. iterations of wfn. opt. steps\n"
"     RANGE: [0, 10000]\n"
"     default: 0\n"
"   nrepmax:\n"
"     COMMENT: Max. number of re-diag. runs\n"
"     RANGE: [0, 1000]\n"
"     default: 1\n"
"     accurate: 10\n"
"   ncong:\n"
"     COMMENT: No. of CG it. for preconditioning eq.\n"
"     RANGE: [0, 20]\n"
"     default: 6\n"
"   idsx:\n"
"     COMMENT: Wfn. diis history\n"
"     RANGE: [0, 15]\n"
"     default: 6\n"
"     low_memory: 2\n"
"   dispersion:\n"
"     COMMENT: Dispersion correction potential (values 1,2,3,4,5), 0=none\n"
"     RANGE: [0, 5]\n"
"     default: 0\n"
"   inputpsiid:\n"
"     COMMENT: Input guess wavefunctions\n"
"     default: 0\n"
"     EXCLUSIVE:\n"
"       -1000: Empty\n"
"       -2:    Random\n"
"       -1:    CP2K\n"
"       0:     LCAO\n"
"       1:     Wvl. in memory\n"
"       2:     Wvl. on disk\n"
"       10:    LCAO + gauss.\n"
"       11:    Gauss. in memory\n"
"       12:    Gauss. on disk\n"
"       100:   Linear AO\n"
"       101:   Linear restart\n"
"       102:   Linear on disk\n"
"     #Here follow two shortcuts for linear\n"
"     linear: 100\n"
"     linear_restart: 102\n"
"   output_wf:\n"
"     COMMENT: Output of the wavefunctions\n"
"     default: 0\n"
"     EXCLUSIVE:\n"
"       0: None\n"
"       1: Plain text\n"
"       2: Fortran binary\n"
"       3: ETSF file format\n"
"   output_denspot:\n"
"     COMMENT: Output of the density or the potential\n"
"     default: 0\n"
"     EXCLUSIVE:\n"
"       0:  None\n"
"       1:  Density in plain text\n"
"       2:  Density and potentials in plain text\n"
"       11: Density in ETSF file format\n"
"       12: Density and potentials in ETSF file format\n"
"       21: Density in cube file format\n"
"       22: Density and potentials in cube file format\n"
"   rbuf:\n"
"     COMMENT: Length of the tail (AU)\n"
"     RANGE: [0., 10.]\n"
"     default: 0.\n"
"     #Here shortcut\n"
"     with tails: 5.\n"
"   ncongt:\n"
"     COMMENT: No. of tail CG iterations\n"
"     RANGE: [0, 50]\n"
"     default: 30\n"
"   norbv:\n"
"     COMMENT: Davidson subspace dimension (No. virtual orbitals)\n"
"     DESCRIPTION: Determine the dimension of the subspace i.e. the number of virtual orbitals\n"
"                  to calculate via a Davidson diagonalisation.\n"
"     RANGE: [-9999, 9999]\n"
"     default: 0\n"
"   nvirt:\n"
"     COMMENT: No. of virtual orbs\n"
"     DESCRIPTION: Number of virtual (unoccupied) orbital to optimize\n"
"                  (should be < norbv)\n"
"     RANGE: [0, 9999]\n"
"     default: 0\n"
"   nplot:\n"
"     COMMENT: No. of plotted orbs\n"
"     DESCRIPTION: Number of orbitals to be plotted\n"
"     RANGE: [0, 9999]\n"
"     default: 0\n"
"   disablesym:\n"
"     COMMENT: Disable the symmetry detection\n"
"     DESCRIPTION: Disable the symmetry detection (by default No except for isolated systems)\n"
"     default: No\n"
"\n"
"#K points parameters\n"
" kpt:\n"
"   DESCRIPTION: K points defined in the Brillouin zone for periodic system calculations\n"
"   method:\n"
"     COMMENT: K-point sampling method\n"
"     EXCLUSIVE:\n"
"       auto:   Based on kptrlen\n"
"       MPGrid: Monkhorst-Pack\n"
"       manual: Based on raw coordinates\n"
"     default:  manual\n"
"   kptrlen:\n"
"     COMMENT: Equivalent length of K-space resolution (Bohr)\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - auto\n"
"     RANGE: [0, 1e4]\n"
"     default: 0.\n"
"   ngkpt:\n"
"     COMMENT: No. of Monkhorst-Pack grid points\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - MPGrid\n"
"     RANGE: [1, 10000]\n"
"     default: [1, 1, 1]\n"
"   shiftk:\n"
"     COMMENT: Grid shifts\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - MPGrid\n"
"     default: [[0., 0., 0.]]\n"
"   kpt:\n"
"     COMMENT: Kpt coordinates\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - manual\n"
"     default:\n"
"     -  [0., 0., 0.]\n"
"   wkpt:\n"
"     COMMENT: Kpt weights\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - manual\n"
"     RANGE: [0., 1e4]\n"
"     default:\n"
"     - 1.\n"
"   bands:\n"
"     COMMENT: For doing band structure calculation\n"
"     default: No\n"
"   iseg:\n"
"     COMMENT: Points for each segment of the Brillouin zone path\n"
"     CONDITION:\n"
"       MASTER_KEY: bands\n"
"       WHEN:\n"
"       - Yes\n"
"     default:\n"
"     - 1\n"
"   kptv:\n"
"     COMMENT: K points defining each segment of the Brillouin zone path\n"
"     CONDITION:\n"
"       MASTER_KEY: bands\n"
"       WHEN:\n"
"       - Yes\n"
"     default:\n"
"     -  [0., 0., 0.]\n"
"     -  [0.5, 0.5, 0.5]\n"
"   ngranularity:\n"
"     COMMENT: No. of points done for each group\n"
"     CONDITION:\n"
"       MASTER_KEY: bands\n"
"       WHEN:\n"
"       - Yes\n"
"     RANGE: [1, 1000]\n"
"     default: 1\n"
"   band_structure_filename:\n"
"     COMMENT: Filename given the local potential for band structure calculations\n"
"     CONDITION:\n"
"       MASTER_KEY: bands\n"
"       WHEN:\n"
"       - Yes\n"
"     default: ''\n"
"\n"
"#Geometry Optimisation  and Molecular Dynamics parameters\n"
" geopt:\n"
"   DESCRIPTION: Parameters for the geometry relaxation and molecular dynamics\n"
"   method:\n"
"     COMMENT: Geometry optimisation method\n"
"     EXCLUSIVE:\n"
"       none:   No geometry optimization\n"
"       SDCG:   A combination of Steepest Descent and Conjugate Gradient\n"
"       VSSD:   Variable Stepsize Steepest Descent method\n"
"       LBFGS:  Limited-memory BFGS\n"
"       BFGS:   Broyden-Fletcher-Goldfarb-Shanno\n"
"       PBFGS:  Same as BFGS with an initial Hessian obtained from a force field\n"
"       AB6MD:  Molecular dynamics from ABINIT\n"
"       DIIS:   Direct inversion of iterative subspace\n"
"       FIRE:   Fast Inertial Relaxation Engine as described by Bitzek et al.\n"
"       NEB:    Nudged Elastic Band\n"
"       SBFGS:  Stefans new optimizer\n"
"     default: none\n"
"   ncount_cluster_x:\n"
"     COMMENT: Maximum number of force evaluations\n"
"     RANGE: [0, 2000]\n"
"     PROFILE_FROM: method\n"
"     default: 50\n"
"     none: 1\n"
"   frac_fluct:\n"
"     COMMENT: Fraction of force fluctuations. Stop if fmax < forces_fluct*frac_fluct\n"
"     RANGE: [0., 10.]\n"
"     default: 1.\n"
"   forcemax:\n"
"     COMMENT: Max forces criterion when stop\n"
"     RANGE: [0., 10.]\n"
"     PROFILE_FROM: method\n"
"     default: 0.\n"
"     NEB: 5e-3\n"
"   randdis:\n"
"     COMMENT: Random displacement amplitude\n"
"     RANGE: [0., 10.]\n"
"     default: 0.\n"
"   betax:\n"
"     COMMENT: Stepsize for the geometry optimization\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - SDCG\n"
"       - VSSD\n"
"       - LBFGS\n"
"       - BFGS\n"
"       - PBFGS\n"
"       - DIIS\n"
"       - FIRE\n"
"       - NEB\n"
"       - SBFGS\n"
"       - none\n"
"     PROFILE_FROM: method\n"
"     RANGE: [0., 100.]\n"
"     default: 4.\n"
"     DIIS: 2.\n"
"     NEB: 0.5\n"
"   history:\n"
"     COMMENT: History for DIIS method\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - DIIS\n"
"     RANGE: [0, 100]\n"
"     default: 4\n"
"   dtinit:\n"
"     COMMENT: Initial time step for the FIRE method\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - FIRE\n"
"     RANGE: [0, 1e4]\n"
"     default: 0.75\n"
"   dtmax:\n"
"     COMMENT: Maximal time step for the FIRE method\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - FIRE\n"
"     RANGE: [0, 1e4]\n"
"     default: 1.5\n"
"   nhistx:\n"
"     COMMENT: maximum history length\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - SBFGS\n"
"     RANGE: [0, 1000]\n"
"     default: 10\n"
"   biomode:\n"
"     COMMENT: Enable mode for biomolecules.\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - SBFGS\n"
"     default: No\n"
"   beta_stretchx:\n"
"     COMMENT: Stepsize for steepest descent in stretching mode direction (only if in biomode)\n"
"     CONDITION:\n"
"       MASTER_KEY: biomode\n"
"       WHEN:\n"
"       - Yes\n"
"     RANGE: [0., 100.]\n"
"     default: 5e-1\n"
"   maxrise:\n"
"     COMMENT: maximum allowed rise in energy in one geopt step\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - SBFGS\n"
"     RANGE: [0., 1e10]\n"
"     default: 1e-6\n"
"   cutoffratio:\n"
"     COMMENT: if ratio of eigenvalues of displacement overlapmatrix is smaller than cutoffratio, the corresponding directions are not used\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - SBFGS\n"
"     RANGE: [0., 1.]\n"
"     default: 1e-4\n"
"   steepthresh:\n"
"     COMMENT: if fnrm < steepthresh, geopt method uses steepest descent\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - SBFGS\n"
"     RANGE: [0., 1e10]\n"
"     default: 0.5\n"
"   trustr:\n"
"     COMMENT: maximum displacement of single atom\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - SBFGS\n"
"     RANGE: [0., 1e10]\n"
"     default: 0.5\n"
"   ionmov:\n"
"     COMMENT: Movement ion method\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - AB6MD\n"
"     EXCLUSIVE:\n"
"       6:  Simple velocity-Verlet molecular dynamic\n"
"       7:  Quenched molecular dynamic\n"
"       8:  Nose-Hoover thermostat\n"
"       9:  Langevin dynamic\n"
"       12: Isokinetic ensemble molecular dynamics\n"
"       13: Iosthermal/isenthalpic ensemble\n"
"     default: 6\n"
"   dtion:\n"
"     COMMENT: Time step - Atomic Units (20.670689 AU=0.5 fs)\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - AB6MD\n"
"     RANGE: [0, 1e3]\n"
"     default: 20.670689\n"
"   mditemp:\n"
"     COMMENT: Temperature of molecular dynamics\n"
"     CONDITION:\n"
"       MASTER_KEY: ionmov\n"
"       WHEN: [8, 9, 12, 13]\n"
"#       - 6\n"
"     RANGE: [0, 1e9]\n"
"     default: 300.\n"
"   mdftemp:\n"
"     COMMENT: Final temperature of molecular dynamics\n"
"     CONDITION:\n"
"       MASTER_KEY: ionmov\n"
"       WHEN: [8, 9, 12, 13]\n"
"     RANGE: [0, 1e9]\n"
"     default: 300.\n"
"   noseinert:\n"
"     COMMENT: Thermostat inertia coefficient for Nose_Hoover dynamics\n"
"     CONDITION:\n"
"       MASTER_KEY: ionmov\n"
"       WHEN:\n"
"       - 8\n"
"     RANGE: [0, 1e9]\n"
"     default: 1e5\n"
"   friction:\n"
"     COMMENT: Friction coefficient for Langevin dynamics\n"
"     CONDITION:\n"
"       MASTER_KEY: ionmov\n"
"       WHEN:\n"
"       - 9\n"
"     RANGE: [0, 1e5]\n"
"     default: 1e-3\n"
"   mdwall:\n"
"     COMMENT: Distance in bohr where atoms can bounce for Langevin dynamics\n"
"     CONDITION:\n"
"       MASTER_KEY: ionmov\n"
"       WHEN:\n"
"       - 9\n"
"     RANGE: [0, 1e5]\n"
"     default: 1e4\n"
"   qmass:\n"
"     COMMENT: Mass of each thermostat (isothermal/isenthalpic ensemble)\n"
"     CONDITION:\n"
"       MASTER_KEY: ionmov\n"
"       WHEN:\n"
"       - 13\n"
"     RANGE: [0, 1e9]\n"
"     default:\n"
"     - 0.\n"
"   bmass:\n"
"     COMMENT: Barostat masses (isothermal/isenthalpic ensemble)\n"
"     CONDITION:\n"
"       MASTER_KEY: ionmov\n"
"       WHEN:\n"
"       - 13\n"
"     RANGE: [0, 1e9]\n"
"     default: 10.\n"
"   vmass:\n"
"     COMMENT: Barostat masses (isothermal/isenthalpic ensemble)\n"
"     CONDITION:\n"
"       MASTER_KEY: ionmov\n"
"       WHEN:\n"
"       - 13\n"
"     RANGE: [0, 1e9]\n"
"     default: 1.\n"
"   climbing:\n"
"     COMMENT: make the highest energy image to climb along the path\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - NEB\n"
"     default: No\n"
"   extrema_opt:\n"
"     COMMENT: minimize the energy of extremum images during NEB optimization\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - NEB\n"
"     default: No\n"
"   neb_method:\n"
"     COMMENT: image minimization method\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - NEB\n"
"     EXCLUSIVE:\n"
"       steepest_descent: steepest descent\n"
"       fletcher-reeves: Fletcher Reeves\n"
"       polak-ribiere: Polak Ribiere\n"
"       quick-min: Conjugate gradient\n"
"       damped-verlet: Verlet with damp\n"
"       sim-annealing: Simulation of annealing\n"
"     default: quick-min\n"
"   temp:\n"
"     COMMENT: temperature for simulated annealing\n"
"     RANGE: [0.,1000.]\n"
"     default: 0.\n"
"     CONDITION:\n"
"       MASTER_KEY: neb_method\n"
"       WHEN:\n"
"       - sim-annealing\n"
"   damp:\n"
"     COMMENT: damping factor\n"
"     RANGE: [0.,1000.]\n"
"     default: 1.\n"
"     CONDITION:\n"
"       MASTER_KEY: neb_method\n"
"       WHEN:\n"
"       - damped-verlet\n"
"   springs_k:\n"
"     COMMENT: maximum and minimum value when changing spring constant during optimization\n"
"     RANGE: [0.,1000.]\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - NEB\n"
"     default: [0.05,0.1]\n"
"   fix_tol:\n"
"     COMMENT: tolerance to apply on atom moves between extrema\n"
"     RANGE: [0,100]\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - NEB\n"
"     default: 1e-4\n"
"   nimg:\n"
"     COMMENT: number of images\n"
"     RANGE: [3,100]\n"
"     CONDITION:\n"
"       MASTER_KEY: method\n"
"       WHEN:\n"
"       - NEB\n"
"     default: 15\n"
"\n"
"#Mixing parameters (do diagonalisation scheme instead of direct minimisation one)\n"
" mix:\n"
"   DESCRIPTION: Mixing parameters for SCF\n"
"   iscf:\n"
"     COMMENT: Mixing parameters\n"
"     DESCRIPTION: Describe the scheme used to solve the self-consistent field\n"
"     EXCLUSIVE:\n"
"       -1: Reserved, do not use it.\n"
"       0:  Direct minimization\n"
"       1:  Get the largest eigenvalue of the SCF cycle\n"
"       2:  Simple mixing of the potential\n"
"       3:  Anderson mixing of the potential\n"
"       4:  Anderson mixing of the potential based on the two previous iterations\n"
"       5:  CG based on the minim. of the energy with respect to the potential\n"
"       7:  Pulay mixing of the potential based on npulayit previous iterations\n"
"       12: Simple mixing of the density\n"
"       13: Anderson mixing of the density\n"
"       14: Anderson mixing of the density based on the two previous iterations\n"
"       15: CG based on the minim. of the energy with respect to the density\n"
"       17: Pulay mixing of the density\n"
"     default: 0\n"
"   itrpmax:\n"
"     COMMENT: Maximum number of diagonalisation iterations\n"
"     RANGE: [0, 10000]\n"
"     default: 1\n"
"   rpnrm_cv:\n"
"     COMMENT: Stop criterion on the residue of potential or density\n"
"     RANGE: [0., 10.]\n"
"     default: 1e-4\n"
"   norbsempty:\n"
"     COMMENT: No. of additional bands\n"
"     RANGE: [0, 10000]\n"
"     default: 0\n"
"   tel:\n"
"     COMMENT: Electronic temperature\n"
"     RANGE: [0., 1e6]\n"
"     default: 0.\n"
"   occopt:\n"
"     COMMENT: Smearing method\n"
"     EXCLUSIVE:\n"
"       1: Error function smearing\n"
"       2: Normal Fermi distribution\n"
"       3: Marzari cold smearing a=-.5634 (bumb minimization)\n"
"       4: Marzari cold smearing with a=-.8165 (monotonic tail)\n"
"       5: Methfessel and Paxton (same as cold with a=0)\n"
"     default: 1\n"
"   alphamix:\n"
"     COMMENT: Multiplying factors for the mixing\n"
"     RANGE: [0, 1.]\n"
"     default: 0.\n"
"   alphadiis:\n"
"     COMMENT: Multiplying factors for the electronic DIIS\n"
"     RANGE: [0., 10.]\n"
"     default: 2.\n"
"\n"
"#Self-Interaction Correction\n"
" sic:\n"
"   DESCRIPTION: Self-Interaction Correction parameters \n"
"   sic_approach:\n"
"     COMMENT: SIC (self-interaction correction) method\n"
"     EXCLUSIVE:\n"
"       none: No self-interaction correction\n"
"       PZ:   Perdew-Zunger SIC scheme\n"
"       NK:   Non-Koopmans correction (Experimental)\n"
"     default: none\n"
"   sic_alpha:\n"
"     COMMENT: SIC downscaling parameter\n"
"     RANGE: [0, 1.]\n"
"     default: 0.\n"
"   sic_fref:\n"
"     COMMENT: Reference occupation fref (for Non-Koopman case only)\n"
"     CONDITION:\n"
"       MASTER_KEY: sic_approach\n"
"       WHEN:\n"
"       - NK\n"
"     RANGE: [0., 1.]\n"
"     default: 0.\n"
"#Time-Dependent DFT parameters\n"
" tddft:\n"
"   tddft_approach:\n"
"     COMMENT: Time-Dependent DFT method\n"
"     EXCLUSIVE:\n"
"       none: no tddft post-processing\n"
"       TDA: ???\n"
"     default: none\n"
"#Performance parameters\n"
" perf:\n"
"   debug:\n"
"     COMMENT: Debug option\n"
"     default: No\n"
"   fftcache:\n"
"     COMMENT: Cache size for the FFT\n"
"     default: 8192\n"
"   accel:\n"
"     COMMENT: Acceleration (hardware) \n"
"     EXCLUSIVE:\n"
"       NO:      No material acceleration\n"
"       CUDAGPU: CUDA\n"
"       OCLGPU:  OpenCL on GPU\n"
"       OCLCPU:  OpenCL on CPU\n"
"       OCLACC:  ???\n"
"     default:   NO\n"
"   ocl_platform:\n"
"     COMMENT: Chosen OCL platform\n"
"     default: ~\n"
"   ocl_devices:\n"
"     COMMENT: Chosen OCL devices\n"
"     default: ~\n"
"   blas:\n"
"     COMMENT: CUBLAS acceleration\n"
"     default: No\n"
"   projrad:\n"
"     COMMENT: Radius of the projector as a function of the maxrad\n"
"     RANGE: [0., 100.]\n"
"     default: 15.\n"
"   exctxpar:\n"
"     COMMENT: Exact exchange parallelisation scheme\n"
"     EXCLUSIVE:\n"
"       BC: ???\n"
"       OP2P: ???\n"
"     default: OP2P\n"
"   ig_diag:\n"
"     COMMENT: Input guess (T=Direct, F=Iterative) diag. of Ham.\n"
"     default: Yes\n"
"   ig_norbp:\n"
"     COMMENT: Input guess Orbitals per process for iterative diag.\n"
"     RANGE: [1, 1000]\n"
"     default: 5\n"
"   ig_blocks:\n"
"     COMMENT: Input guess Block sizes for orthonormalisation\n"
"     RANGE: [1, 100000]\n"
"     default: [300, 800]\n"
"   ig_tol:\n"
"     COMMENT: Input guess Tolerance criterion\n"
"     RANGE: [0., 1.]\n"
"     default: 1e-4\n"
"   methortho:\n"
"     COMMENT: Orthogonalisation\n"
"     EXCLUSIVE:\n"
"       0: Cholesky\n"
"       1: Gram-Schmidt/Cholesky\n"
"       2: Loewdin\n"
"     default: 0\n"
"   rho_commun:\n"
"     COMMENT: Density communication scheme (DBL, RSC, MIX)\n"
"     default: DEF\n"
"   psolver_groupsize:\n"
"     COMMENT: Size of Poisson Solver taskgroups (0=nproc)\n"
"     RANGE: [0, 1000000]\n"
"     default: 0\n"
"   psolver_accel:\n"
"     COMMENT: Acceleration of the Poisson Solver (0=none, 1=CUDA)\n"
"     EXCLUSIVE:\n"
"       0: None\n"
"       1: CUDA\n"
"     default: 0\n"
"   unblock_comms:\n"
"     COMMENT: Overlap Communications of fields (OFF,DEN,POT)\n"
"     EXCLUSIVE:\n"
"       OFF: Synchronous run\n"
"       DEN: ???\n"
"       POT: ???\n"
"     default: OFF\n"
"   linear:\n"
"     COMMENT: Linear Input Guess approach\n"
"     EXCLUSIVE:\n"
"       OFF: ???\n"
"       LIG: ???\n"
"       FUL: ???\n"
"       TMO: ???\n"
"     default: OFF\n"
"   tolsym:\n"
"     COMMENT: Tolerance for symmetry detection\n"
"     RANGE: [0., 1.]\n"
"     default: 1e-8\n"
"   signaling:\n"
"     COMMENT: Expose calculation results on Network\n"
"     default: No\n"
"   signaltimeout:\n"
"     COMMENT: Time out on startup for signal connection (in seconds)\n"
"     RANGE: [-1, 3600]\n"
"     default: 0\n"
"   domain:\n"
"     COMMENT: Domain to add to the hostname to find the IP\n"
"     default: ~\n"
"   inguess_geopt:\n"
"     COMMENT: Input guess to be used during the optimization\n"
"     EXCLUSIVE:\n"
"       0: Wavelet input guess\n"
"       1: Real space input guess\n"
"     default: 0\n"
"   store_index:\n"
"     COMMENT: Store indices or recalculate them for linear scaling\n"
"     default: Yes\n"
"   verbosity:\n"
"     COMMENT: Verbosity of the output\n"
"     EXCLUSIVE:\n"
"       0: ???\n"
"       1: ???\n"
"       2: ???\n"
"       3: ???\n"
"     default: 2\n"
"   outdir:\n"
"     COMMENT: Writing directory\n"
"     default: .\n"
"   psp_onfly:\n"
"     COMMENT: Calculate pseudopotential projectors on the fly\n"
"     default: Yes\n"
"   multipole_preserving:\n"
"     COMMENT: (EXPERIMENTAL) Preserve the multipole moment of the ionic density\n"
"     default: No\n"
"   pdsyev_blocksize:\n"
"     COMMENT: SCALAPACK linear scaling blocksize\n"
"     default: -8\n"
"   pdgemm_blocksize:\n"
"     COMMENT: SCALAPACK linear scaling blocksize\n"
"     default: -8\n"
"   maxproc_pdsyev:\n"
"     COMMENT: SCALAPACK linear scaling max num procs\n"
"     default: 4\n"
"   maxproc_pdgemm:\n"
"     COMMENT: SCALAPACK linear scaling max num procs\n"
"     default: 4\n"
"   ef_interpol_det:\n"
"     COMMENT: FOE max determinant of cubic interpolation matrix\n"
"     RANGE: [0., 1.]\n"
"     default: 1.e-12\n"
"   ef_interpol_chargediff:\n"
"     COMMENT: FOE max charge difference for interpolation\n"
"     RANGE: [0., 1000.]\n"
"     default: 10.\n"
"   mixing_after_inputguess:\n"
"     COMMENT: Mixing step after linear input gues\n"
"     EXCLUSIVE:\n"
"       0: keep the initial input guess density\n"
"       1: perform a mixing step with the default mixing parameter\n"
"       2: keep the new density, completely neglecting the input guess density\n"
"     default: 1\n"
"   iterative_orthogonalization:\n"
"     COMMENT: Iterative_orthogonalization for input guess orbitals\n"
"     default: No\n"
"   check_sumrho:\n"
"     COMMENT: Enables linear sumrho check\n"
"     default: 2\n"
"     EXCLUSIVE:\n"
"       0: No check\n"
"       1: Light check\n"
"       2: Full check\n"
"   check_overlap:\n"
"     COMMENT: Enables linear overlap check\n"
"     default: 2\n"
"     EXCLUSIVE:\n"
"       0: No check\n"
"       1: Light check\n"
"       2: Full check\n"
"   experimental_mode:\n"
"     COMMENT: Activate the experimental mode in linear scaling\n"
"     default: No\n"
"   write_orbitals:\n"
"     COMMENT: Linear scaling write KS orbitals for cubic restart (might take lot of disk space!)\n"
"     default: No\n"
"   explicit_locregcenters:\n"
"     COMMENT: Linear scaling explicitely specify localization centers \n"
"     default: No\n"
"   calculate_KS_residue:\n"
"     COMMENT: Linear scaling calculate Kohn-Sham residue\n"
"     default: Yes\n"
"   intermediate_forces:\n"
"     COMMENT: Linear scaling calculate intermediate forces\n"
"     default: No\n"
"   kappa_conv:\n"
"     COMMENT: Exit kappa for extended input guess (experimental mode)\n"
"     default: 0.1\n"
"   evbounds_nsatur:\n"
"     COMMENT: Number of FOE cycles before the eigenvalue bounds are shrinked (linear)\n"
"     default: 3\n"
"   evboundsshrink_nsatur:\n"
"     COMMENT: maximal number of unsuccessful eigenvalue bounds shrinkings\n"
"     default: 4\n"
"   method_updatekernel:\n"
"     COMMENT: linear scaling update density kernel during the sup. func. optimization (0 purification, 1 FOE, 2 renormalization)\n"
"     default: 0\n"
"     EXCLUSIVE:\n"
"       0: purification\n"
"       1: FOE\n"
"       2: renormalization\n"
"   purification_quickreturn:\n"
"     COMMENT: linear scaling quick return in purification\n"
"     default: No\n"
"   adjust_FOE_temperature:\n"
"     COMMENT: linear scaling dynamic adjustment of the decay length of the FOE error function\n"
"     default: Yes\n"
"   calculate_gap:\n"
"     COMMENT: linear scaling calculate the HOMO LUMO gap\n"
"     default: No\n"
"   loewdin_charge_analysis:\n"
"     COMMENT: linear scaling perform a Loewdin charge analysis at the end of the calculation\n"
"     default: No\n"
"   check_matrix_compression:\n"
"     COMMENT: linear scaling perform a check of the matrix compression routines\n"
"     default: Yes\n"
"   correction_co_contra:\n"
"     COMMENT: linear scaling correction covariant / contravariant gradient\n"
"     default: No\n"
"   fscale_lowerbound:\n"
"     COMMENT: linear scaling lower bound for the error function decay length\n"
"     RANGE: [1.e-4,1.e-2]\n"
"     default: 5.e-3\n"
"   fscale_upperbound:\n"
"     COMMENT: linear scaling upper bound for the error function decay length\n"
"     default: 5.e-2\n"
"     RANGE: [1.e-2,1.0]\n"
"   FOE_restart:\n"
"     COMMENT: Restart method to be used for the FOE method\n"
"     EXCLUSVE:\n"
"       0: REFORMAT\n"
"       1: AO\n"
"     default: 0 \n"
"   imethod_overlap:\n"
"     COMMENT: method to calculate the overlap matrices (1=old, 2=new)\n"
"     EXCLUSIVE: \n"
"       1: old\n"
"       2: new\n"
"     default: 1\n"
"   enable_matrix_taskgroups:\n"
"     COMMENT: enable the matrix taskgroups\n"
"     default: True\n"
" lin_general:\n"
"     hybrid: \n"
"       COMMENT: activate the hybrid mode; if activated, only the low accuracy values will be relevant\n"
"       default: No\n"
"     nit:\n"
"       COMMENT: number of iteration with low/high accuracy\n"
"       DESCRIPTION: |\n"
"                    possible value: 2 non-negative integer numbers\n"
"                    Maximal number of outer loop iterations (high / low accuracy).\n"
"                    In each iteration both the support function and the kernel are optimized.\n"
"                    When the hybrid mode is used, only the first entry is taken into account.\n"
"       RANGE: [0,1000]\n"
"       PROFILE_FROM: hybrid\n"
"       default: [100,100]\n"
"       Yes: [100, 1]\n"
"     rpnrm_cv:\n"
"       COMMENT: convergence criterion for low/high accuracy\n"
"       DESCRIPTION: |\n"
"                    possible value: 2 non-negative real numbers\n"
"                    Convergence criterion for the outer loop iterations (high / low accuracy).\n"
"                    The optimization stops if the mean change of the charge density / potential falls below this threshold.\n"
"                    When the hybrid mode is used, only the first entry is taken into account.\n"
"       RANGE: [1.e-15,1.e-5]\n"
"       default: [1.e-12,1.e-12]\n"
"     conf_damping:\n"
"       COMMENT: how the confinement should be decreased, only relevant for hybrid mode; negative -> automatic\n"
"       DESCRIPTION: |\n"
"                    possible value: 1 real number\n"
"                    Prescription how the prefactor for the confining potential should be decreased:\n"
"                     * negative value => automatic adjustment (recommended)\n"
"                     * positive value => at each iteration the prefactor is multiplied with the specified value\n"
"                    This variable is only relevant for the hybrid mode.\n"
"       RANGE: [-1.0,1.0]\n"
"       default: -0.5\n"
"     taylor_order:\n"
"       COMMENT: order of the Taylor approximation; 0 -> exact\n"
"       DESCRIPTION: |\n"
"                    possible value: 1 integer number\n"
"                    Indicates how the matrix powers are calculated:\n"
"                     * n<0 => Laura's method of order n\n"
"                     * n=0 => exact calculation\n"
"                     * n>0 => Taylor series of order n\n"
"       RANGE: [-100,10000]\n"
"       default: 0\n"
"     max_inversion_error:\n"
"       COMMENT: linear scaling maximal error of the Taylor approximations to calculate the inverse of the overlap matrix\n"
"       DESCRIPTION: |\n"
"                    possible value: 1 positive real number\n"
"                    Maximal error of the Taylor approximations which are used to  calculate the inverse of the overlap matrix.\n"
"                    If this error is larger than the specified value, the order of the Taylor approximation is increased.\n"
"                    The default value is set very large, such such in this case no automatic adjustment is performed.\n"
"       default: 1.d0\n"
"       RANGE: [1.e-20,1.0]\n"
"     output_wf:\n"
"       COMMENT: output basis functions; 0 no output, 1 formatted output, 2 Fortran bin, 3 ETSF\n"
"       DESCRIPTION: |\n"
"                    possible value: 1 nonnegative-integer number\n"
"                    Indicates how the support functions should be written to disk at the end of the run:\n"
"                     * 0 => no output\n"
"                     * 1 => formatted output\n"
"                     * 2 => Fortran bin\n"
"                     * 3 => ETSF\n"
"       EXCLUSIVE:\n"
"         0: no output\n"
"         1: formatted output\n"
"         2: Fortran bin\n"
"         3: ETSF\n"
"       default: 0\n"
"     calc_dipole:\n"
"       DESCRIPTION: |\n"
"                    possible value: 1 logical\n"
"                    Indicates whether the dipole moment should be calculated at the run or not\n"
"       COMMENT: calculate dipole\n"
"       default: No\n"
"# this is now an array!\n"
"     calc_pulay:\n"
"       COMMENT: calculate Pulay forces (old/new version)\n"
"       DESCRIPTION: |\n"
"                    possible value: 2 logicals\n"
"                    Indicates whether the Pulay corrections (old / new) shall be calculated at the end of the run\n"
"       default: [No,No]\n"
"       new: [ No, Yes]\n"
"       old: [ Yes, No] \n"
"# this name might be misleading\n"
"     subspace_diag: #called calc_ks, to be renamed\n"
"       COMMENT: diagonalization at the end\n"
"       DESCRIPTION: |\n"
"                    possible value: logical\n"
"                    Indicates whether a diagonliazation shall be performed at the end of the run\n"
"       default: No\n"
"     extra_states:\n"
"       COMMENT: extra states to optimize (dmin only)\n"
"       default: 0\n"
"       RANGE: [0, 10000]\n"
"#Parameters for the localised basis set (or support function) for the linear scaling version\n"
" lin_basis:\n"
"     nit:\n"
"       COMMENT: maximal number of iterations in the optimization of the support functions\n"
"       DESCRIPTION: |\n"
"                    possible value: 2 non-negative integers\n"
"                    Maximal number of iterations in the optimization of the support functions.\n"
"                    The first number is used for the low accuracy part, the second one for the high accuracy part.\n"
"                    If the hybrid mode is used, only the first value is taken into account.\n"
"       RANGE: [0,100]\n"
"       default: [4,5]\n"
"     idsx:\n"
"       COMMENT: DIIS history for optimization of the support functions (low/high accuracy); 0 -> SD\n"
"       DESCRIPTION: |\n"
"                    possible values: 2 non-negative integers\n"
"                    Indicates the method with which the support functions are optimized\n"
"                     * n=0 => steepest descent\n"
"                     * n>0 => DIIS with history length n\n"
"       RANGE: [0,20]\n"
"       default: [6,6]\n"
"     gnrm_cv:\n"
"       COMMENT: convergence criterion for the optimization of the support functions (low/high accuracy)\n"
"       DESCRIPTION: |\n"
"                    possible value: 2 non-negative real numbers\n"
"                    Convergence criterion for optimization of the support functions (high / low accuracy).\n"
"                    The optimization stops if the mean gradient norm falls below this threshold.\n"
"                    When the hybrid mode is used, only the first entry is taken into account.\n"
"       RANGE: [1.e-6,1.0]\n"
"       default: [1.e-2,1.e-4]\n"
"     deltae_cv:\n"
"       COMMENT: total relative energy difference to stop the optimization ('experimental_mode' only)\n"
"       DESCRIPTION: |\n"
"                    possible value: 1 non-negative real number\n"
"                    The optimization of the support functions stops if the total relative gain in the target function during the given cycle of support function optimization falls below this threshold\n"
"       RANGE: [1.e-6,1.e-1]\n"
"       default: 1.e-4\n"
"     gnrm_dyn:\n"
"       COMMENT: dynamic convergence criterion ('experimental_mode' only)\n"
"       DESCRIPTION: |\n"
"                    possible value: 1 non-negative real number\n"
"                    From this value the effective dynamic convergence criterion is calculated by a division by kappa.\n"
"                    Then the optimization of the support functions stops if the mean gradient norm falls below this effective dynamic convergence criterion \n"
"                    and is at the same time smaller than the value of min_gnrm_for_dynamic.\n"
"                    The specified value should be approximately 10 times smaller than the value of gnrm_cv.\n"
"                    This value is only used for the experimental mode.\n"
"       RANGE: [1.e-7,1.e-1]\n"
"       default: 1.e-4\n"
"     min_gnrm_for_dynamic:\n"
"       COMMENT: minimal gnrm to active the dynamic gnrm criterion\n"
"       DESCRIPTION: |\n"
"                    possible value: non-negative real number\n"
"                    The dynamic convergence criterion (specified by gnrm_dyn) is only active if the mean gradient norm of the support functions is below this threshold\n"
"       RANGE: [1.e-7,1.0]\n"
"       default: 1.e-3\n"
"     alpha_diis:\n"
"       COMMENT: multiplicator for DIIS\n"
"       DESCRIPTION: |\n"
"                    possible value: 2 positive real numbers\n"
"                    The support functions gradient is multiplied by this number before being used for the DIIS optimization.\n"
"                    The first entry for the low accuracy part, the second one for the high accuracy part.\n"
"                    When the hybrid mode is used, only the first entry is taken into account.\n"
"       RANGE: [0.1,10]\n"
"       default: 1.0\n"
"     alpha_sd:\n"
"       COMMENT: initial step size for SD\n"
"       DESCRIPTION: |\n"
"                    possible values: 2 positive real numbers\n"
"                    The initial step size which is used to optimize the support functions with steepest descent.\n"
"                    If the specified value is not appropriate, it will be adjusted automatically.\n"
"                    The first entry is used for the low accuracy part, the second one for the high accuracy part.\n"
"                    When the hybrid mode is used, only the first entry is taken into account.\n"
"       RANGE: [1.e-4,10.0]\n"
"       default: 1.0\n"
"     nstep_prec:\n"
"       COMMENT: number of iterations in the preconditioner\n"
"       DESCRIPTION: |\n"
"                    possible values: non-negative integer\n"
"                    Indicates how many iterations in the preconditioning of the gradient shall be performed\n"
"       RANGE: [1,30]\n"
"       default: 5\n"
"     fix_basis:\n"
"       COMMENT: fix the support functions if the density change is below this threshold\n"
"       RANGE: [1.e-14,1.e-6]\n"
"       default: 1.e-10\n"
"     correction_orthoconstraint:\n"
"       COMMENT: correction for the slight non-orthonormality in the orthoconstraint\n"
"       DESCRIPTION: |\n"
"                    possible values: non-negative integer\n"
"                    Indicates whether the slight non-orthogonality of the support functions should be taken into account during the application of the orthogonality constraint:\n"
"                      * 0 => take into account\n"
"                      * 1 => don't take into account\n"
"       default: 1 \n"
" #Parameters for the calculation of the kernel (linear scaling version)\n"
" lin_kernel:\n"
"     nstep:\n"
"       COMMENT: number of steps taken when updating the coefficients via direct minimization for each iteration of the density kernel loop\n"
"       DESCRIPTION: |\n"
"                    possible value: 2 non-negative integers\n"
"                    Indicates the number of steps taken when updating the coefficients via direct minimization for each iteration of the density kernel loop.\n"
"                    The first entry is used for the low accuracy part, the second one for the high accuracy part.\n"
"                    When the hybrid mode is used, only the first entry is taken into account.\n"
"       RANGE: [0,100]\n"
"       default: [1,1]\n"
"     nit:\n"
"       COMMENT: number of iterations in the (self-consistent) optimization of the density kernel\n"
"       DESCRIPTION: |\n"
"                    possible value: 2 non-negative integers\n"
"                    Indicates the number of iterations in the (self-consistent) optimization of the density kernel.\n"
"                    The first entry is used for the low accuracy part, the second one for the high accuracy part.\n"
"                    When the hybrid mode is used, only the first entry is taken into account.\n"
"       RANGE: [0,100]\n"
"       default: [5,5]\n"
"# check whether there are different DIIS histories...\n"
"     idsx_coeff:\n"
"       COMMENT: DIIS history for direct mininimization\n"
"       default: [0,0]\n"
"     idsx:\n"
"       COMMENT: mixing method; 0 -> linear mixing, >=1 -> Pulay mixing\n"
"       DESCRIPTION: |\n"
"                    possible value: 2 non-negative integer numbers\n"
"                    Indicates how the density / potential mixing shall be performed:\n"
"                    n=0 => linear mixing\n"
"                    n=1 => Pulay mixing with history length n\n"
"                    The first entry is used for the low accuracy part, the second one for the high accuracy part.\n"
"                    When the hybrid mode is used, only the first entry is taken into account.\n"
"       RANGE: [0,20]\n"
"       default: [0,0]\n"
"     alphamix:\n"
"       COMMENT: mixing parameter (low/high accuracy)\n"
"       DESCRIPTION: |\n"
"                    possible value: 2 non-negative real numbers\n"
"                    Indicates the mixing parameter used for the mixing of the charge density / potential.\n"
"                    The larger the value, the more of the previous value will be kept.\n"
"                    The first entry is used for the low accuracy part, the second one for the high accuracy part.\n"
"                    When the hybrid mode is used, only the first entry is taken into account.\n"
"       RANGE: [0.0,1.0]\n"
"       default: [0.5,0.5]\n"
"     gnrm_cv_coeff:\n"
"       COMMENT: convergence criterion on the gradient for direct minimization\n"
"       DESCRIPTION: |\n"
"                    possible value: 2 non-negative real numbers\n"
"                    Convergence criterion on the gradient for direct minimization.\n"
"                    The first entry is used for the low accuracy part, the second one for the high accuracy part.\n"
"                    When the hybrid mode is used, only the first entry is taken into account.\n"
"       default: [1.e-5,1.e-5]\n"
"     rpnrm_cv:\n"
"       COMMENT: convergence criterion (change in density/potential) for the kernel optimization\n"
"       DESCRIPTION: |\n"
"                    possible value: 2 non-negative real numbers\n"
"                    The optimization of the density kernel is stopped as soon as the mean change of the charge density / potential between two iterations falls below this threshold.\n"
"                    The first entry is used for the low accuracy part, the second one for the high accuracy part.\n"
"                    When the hybrid mode is used, only the first entry is taken into account.\n"
"       RANGE: [1.e-14,1.e-5]\n"
"       default: [1.e-10,1.e-10]\n"
"     linear_method:\n"
"       COMMENT: method to optimize the density kernel\n"
"       DESCRIPTION: |\n"
"                    possible value: string\n"
"                    Indicates the method with which the density kernel is optimized:\n"
"                     * DIRMIN => direct minimization\n"
"                     * DIAG => diagonalization with density mixing\n"
"                     * FOE => Fermi Operator Expansion\n"
"       EXCLUSIVE:\n"
"         DIRMIN: direct minimization\n"
"         DIAG: diagonalization\n"
"         FOE: Fermi Operator Expansion\n"
"       default: DIAG\n"
"     mixing_method:\n"
"       COMMENT: quantity to be mixed\n"
"       DESCRIPTION: |\n"
"                    type: string scalar\n"
"                    Indicates which quantity should be used for the mixing procedure:\n"
"                     DEN => density mixing\n"
"                     POT => potential mixing\n"
"       EXCLUSIVE:\n"
"         DEN: density mixing\n"
"         POT: potential mixing\n"
"       default: DEN\n"
"     alpha_sd_coeff:\n"
"       COMMENT: initial step size for SD for direct minimization\n"
"       default: 0.2\n"
"     alpha_fit_coeff:\n"
"       COMMENT: update the SD step size by fitting a quadratic polynomial to the energy along the direction of the gradient during direct mininimization.     \n"
"       default: No\n"
"     eval_range_foe:\n"
"       COMMENT: lower and upper bound of the eigenvalue spectrum, will be adjusted automatically if chosen unproperly\n"
"       DESCRIPTION: |\n"
"                    possible value: 2 real numbers (one negative, one positive)\n"
"                    Indicates the lower and upper bound of the eigenvalue spectrum which is used for the Fermi Operator Expansion.\n"
"                    This spectrum will be adjusted automatically if not chosen appropriately.\n"
"       RANGE: [-10.0,10.0]\n"
"       default: [-0.5,0.5]\n"
"     fscale_foe: \n"
"       COMMENT: decay length of the error function\n"
"       DESCRIPTION: |\n"
"                    possible value: 1 non-negative real number\n"
"                    Indicates the decay length of the error function which is used by the Fermi Operator Expasion to construct the density kernel.\n"
"                    This value will be adjusted automatically if not chosen appropriately.\n"
"       RANGE: [1.e-3,5.e-2]\n"
"       default: 2.e-2\n"
"#Parameters to define the localized basis set or support functions (linear scaling version)\n"
" lin_basis_params:\n"
"     nbasis:\n"
"       COMMENT: number of support functions per atom\n"
"       DESCRIPTION: |\n"
"                    possible value: 1 positive integer\n"
"                    Indicates the number of support fuctions centered on this atom type. Possible values are:\n"
"                     * 1 (s orbital type)\n"
"                     * 4 (s,p orbital types)\n"
"                     * 9 (s,p,d orbital types)\n"
"                     * 16 (s,p,d,f orbital types)\n"
"       EXCLUSIVE:\n"
"         1: s orbital type\n"
"         4: s,p orbital types\n"
"         9: s,p,d orbital types\n"
"         16: s,p,d,f orbital types\n"
"       default: 4\n"
"     ao_confinement:\n"
"       COMMENT: prefactor for the input guess confining potential\n"
"       DESCRIPTION: |\n"
"                    possible value: 1 non-negative real value\n"
"                    Indicates the prefactor of the confining potential of this atom type which is used to generate the input guess.\n"
"       RANGE: [0.0,10.0]\n"
"       default: 8.3e-3\n"
"     confinement:\n"
"       COMMENT: prefactor for the confining potential (low/high accuracy)\n"
"       DESCRIPTION: |\n"
"                    possible value: 2 non-negative real values\n"
"                    Indicates the prefactor of the confining potential of this atom type.\n"
"                    The first entry is used for the low accuracy part, the second one for the high accuracy part.\n"
"                    When the hybrid mode is used, only the first entry is taken into account.\n"
"       RANGE: [0.0,10.0]\n"
"       default: [8.3e-3,0.0]\n"
"     rloc:\n"
"       COMMENT: localization radius for the support functions\n"
"       DESCRIPTION: |\n"
"                    possible value: 2 real numbers\n"
"                    Indicates the cutoff radius for the support functions.\n"
"                    The first entry is used for the low accuracy part, the second one for the high accuracy part; the second value must not be smaller than the first one.\n"
"                    When the hybrid mode is used, only the first entry is taken into account.\n"
"       RANGE: [2.0,1000.0]\n"
"       default: [7.0,7.0]\n"
"     rloc_kernel:\n"
"       COMMENT: localization radius for the density kernel\n"
"       DESCRIPTION: |\n"
"                    possible value: 1 real number\n"
"                    Indicates the cutoff radius for the density kernel.\n"
"                    Must be at least as large as the support function cutoff plus 8 times the grid spacing; will be adjusted automatically if it is chosen too small.\n"
"       RANGE: [2.0,1000.0] \n"
"       default: 9.0\n"
"     rloc_kernel_foe:\n"
"       COMMENT: cutoff radius for the FOE matrix vector multiplications\n"
"       DESCRIPTION: |\n"
"                    possible value: 1 real number\n"
"                    Indicates the cutoff radius used for the matrix vector multiplications.\n"
"                    Must be at least as large as the kernel cutoff.\n"
"       RANGE: [2.0,1000]\n"
"       default: 14.0\n"
"--- #here starts the document of possible input files\n"
"linear_accurate:\n"
"  COMMENT: appropriate input parameters for a high accuracy linear scaling calculation\n"
"  DESCRIPTION: This profile should be chosen if highly accurate energy differences are required\n"
"  dft:\n"
"    hgrids: accurate\n"
"    ixc: PBE\n"
"  perf:\n"
"    ef_interpol_chargediff: 1.0\n"
"    experimental_mode: Yes\n"
"    method_updatekernel: 2\n"
"    purification_quickreturn: Yes\n"
"    correction_co_contra: Yes\n"
"    #check_sumrho: 1\n"
"    #calculate_KS_residue: No\n"
"    #check_matrix_compression: No\n"
"  lin_general:\n"
"    hybrid: Yes\n"
"    taylor_order: 1015\n"
"    max_inversion_error: 5.0e-8\n"
"  lin_basis:\n"
"    nit: 8\n"
"    idsx: 8\n"
"    gnrm_cv: 1.e-3\n"
"    gnrm_dyn: 1.e-4\n"
"    deltae_cv: 5.e-5\n"
"    min_gnrm_for_dynamic: 2.e-3\n"
"    alpha_diis: 0.5\n"
"    alpha_sd: 0.5\n"
"    nstep_prec: 6\n"
"    fix_basis: 1.0e-12\n"
"    correction_orthoconstraint: 0\n"
"  lin_kernel:\n"
"    nit: 4\n"
"    idsx: 6\n"
"    alphamix: 0.1\n"
"    rpnrm_cv: [1.e-12,1.e-12]\n"
"    linear_method: FOE\n"
"linear_moderate:\n"
"  COMMENT: appropriate input parameters for a moderate accuracy linear scaling calculation\n"
"  DESCRIPTION: This profile should be chosen if accurate forces are required, but there is no need for extremely accurate energies\n"
"  dft:\n"
"    hgrids: accurate\n"
"    ixc: PBE\n"
"  perf:\n"
"    ef_interpol_chargediff: 1.0\n"
"    experimental_mode: Yes\n"
"    method_updatekernel: 2\n"
"    purification_quickreturn: Yes\n"
"    correction_co_contra: Yes\n"
"  lin_general:\n"
"    hybrid: Yes\n"
"    taylor_order: 10\n"
"  lin_basis:\n"
"    nit: [10,10]\n"
"    gnrm_cv: [2.e-3,2.e-3]\n"
"    gnrm_dyn: 2.e-4\n"
"    deltae_cv: 5.e-5\n"
"    min_gnrm_for_dynamic: 4.e-3\n"
"    alpha_diis: 0.5\n"
"    alpha_sd: 0.5\n"
"    nstep_prec: 6\n"
"    fix_basis: 1.e-11\n"
"    correction_orthoconstraint: 0\n"
"  lin_kernel:\n"
"    nit: [3,3]\n"
"    idsx: [6,6]\n"
"    alphamix: [0.2,0.2]\n"
"    rpnrm_cv: [1.e-11,1.e-11]\n"
"    linear_method: FOE\n"
"linear_fast:\n"
"  COMMENT: appropriate input parameters for a low accuracy linear scaling calculation\n"
"  DESCRIPTION: This profile should be chosen if speed is more important than accuracy\n"
"  dft:\n"
"    hgrids: accurate\n"
"    ixc: PBE\n"
"  perf:\n"
"    ef_interpol_chargediff: 1.0\n"
"    experimental_mode: Yes\n"
"    method_updatekernel: 2\n"
"    purification_quickreturn: Yes\n"
"    correction_co_contra: Yes\n"
"  lin_general:\n"
"    hybrid: Yes\n"
"    taylor_order: 10\n"
"  lin_basis:\n"
"    nit: [10,10]\n"
"    gnrm_cv: [4.e-3,4.e-3]\n"
"    gnrm_dyn: 4.e-4\n"
"    deltae_cv: 5.e-5\n"
"    min_gnrm_for_dynamic: 8.e-3\n"
"    alpha_diis: 0.5\n"
"    alpha_sd: 0.5\n"
"    nstep_prec: 6\n"
"    fix_basis: 1.e-10\n"
"    correction_orthoconstraint: 0\n"
"  lin_kernel:\n"
"    nit: [10,10]\n"
"    idsx: [6,0]\n"
"    alphamix: [0.2,0.2]\n"
"    rpnrm_cv: [1.e-10,1.e-10]\n"
"    linear_method: FOE\n"
"structural:\n"
"  COMMENT: for geopt\n"
"  dft:\n"
"    hgrids: fast\n"
"    ixc: PBE\n"
"  geopt:\n"
"    method: FIRE\n"
